{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to lv2tutorials!</p>"},{"location":"#resources","title":"Resources","text":"<ul> <li>LV2 specifications: https://lv2plug.in/ns/</li> <li>LV2 book: https://lv2plug.in/book/</li> </ul>"},{"location":"#further-reading","title":"Further reading","text":"<p>TODO</p>"},{"location":"1_00_announce/","title":"00 - Announce","text":"<p>See video: https://www.youtube.com/watch?v=51eHCA4oCEI</p>"},{"location":"1_01_what_is_lv2/","title":"01 - Introduction: What is LV2?","text":"<p>See video:https://www.youtube.com/watch?v=AdB2pLCFQY4</p> <p>LV2 is a free and open source audio plugin standard. LV2 is available on Linux, Mac, Windows, and on other systems. There are more than 1000 LV2 plugins available by now. And the number is growing.</p> <p>LV2 is exensible and stores its meta-data (like plugin name, plugin type, and ports used) in separate files. This allows to get plugin informations without loading and executing the plugin.</p> <p>To create LV2 plugins, you need:</p> <ul> <li>a C/C++ compiler (gcc, Clang or MSVC),</li> <li>an editor (Atom, Eclipse, VS Code, KDevelop, or ...),</li> <li>and some developer libraries:</li> <li>C/C++ libraries</li> <li>LV2</li> <li>sndfile</li> <li>X11 (or ...)</li> <li>Cairo</li> <li>pkg-config</li> </ul> <p>On Debian linux-based systems you can get them by calling from the terminal:</p> <pre><code>sudo apt-get install build-essential\nsudo apt-get install pkg-config lv2-dev libsndfile1-dev libx11-dev libcairo2-dev\n</code></pre> <p>And on Arch linux-based systems you can get them by calling from the terminal:</p> <pre><code>sudo pacman -S base-devel\nsudo pacman -S pkg-config lv2 libsndfile libX11-dev cairo\n</code></pre> <p>Recommended optional tools: * Jalv (minimal LV2 host) * lv2lint (validation) * gdb (debugger) * valgrind (memory debugging / leak detection)</p>"},{"location":"1_02_simple_amp_1/","title":"02 - A Simple Amplifier (Part 1) - Do The Turtle","text":"<p>See video: https://www.youtube.com/watch?v=aKN89LnmbvQ</p> <p>Introduction to the basic principles of the Turtle description language. Subject, predicate, and object. And URIs. Define the metadata for a simple amplifier plugin.</p> <ul> <li>usefulinc.ttl</li> <li>LV2</li> <li>RDF</li> </ul>"},{"location":"1_03_how_lv2_plugins_work/","title":"03 - How LV2 Plugins Work","text":"<p>See video: https://www.youtube.com/watch?v=Zg-YUbfO6ww</p> <p>This videos provides a look under the hood of an LV2 plugin and shows how it works inside a DAW. The plugin has to provide: * a manifest (and a linked plugin turtle file) for the plugin metadata, and * a plugin binary file with   * a C interface function   * the seven core functions     * instantiate     * connect_port     * activate     * run     * deactivate     * cleanup     * extension_data   * a plugin class definition (at least) with pointers to the buffers provided by the DAW (ports).</p> <p>The DAW has to provide: * buffers for audio in, audio out, ... * buffers for the controllers * functions to call the plugin functions.</p>"},{"location":"1_04_simple_amp_2/","title":"04 - A Simple Amplifier Plugin (Part 2) - Code, Compile &amp; Run","text":"<p>See video: https://youtu.be/XSxZ4_SdqIQ</p> <p>Coding in C. Basic introduction into C programming and what we need to make LV2 plugins: * a class definition using <code>typedef struct</code>, * the seven core functions called:   * instantiate,   * connect_port,   * activate,   * run,   * deactivate,   * cleanup, and   * extension_data * a descriptor struct which contains:   * the plugin URI as a C string and   * the pointers to the seven core functions (or <code>NULL</code> if not needed), and * a C interface function which returns a pointer to the descriptor struct.</p> <p>Compile the code from the code directory with:</p> <pre><code>gcc -fvisibility=hidden -fPIC -Wl,-Bstatic -Wl,-Bdynamic -Wl,--as-needed -shared -pthread `pkg-config --cflags lv2` -lm `pkg-config --libs lv2` myAmp.c -o myAmp.so\n</code></pre> <p>Copy the resulting .so file and the two .ttl files into a newly created subfolder (I call this folder <code>myAmp.lv2/</code>) in one of your systems LV2 folders. Like the hidden LV2 folder of your home directory: <code>~/.lv2/</code>.</p> <p>Then you can test the plugin in an LV2 host, like the minimalistic jalv:</p> <pre><code>jalv.gtk3 https://github.com/sjaehn/lv2tutorial/myAmp\n</code></pre> <p>(gtk3 may be replaced by one of the other jalv variants). Or feel free to directly test myAmp within a DAW.</p> <p>Now we completed our first LV2 plugin!</p>"},{"location":"1_05_sound_gen_cpp/","title":"05 - A Sound Generator In C++","text":"<p>See video: https://youtu.be/uvskHCJrJcY</p> <p>Programming a test tone generator as a first step to make a software synthesizer.</p> <p>Topics: * Introduction in classic C++. * LV2 extensions: Units, Port Properties * Writing a sine wave to the audio output</p>"},{"location":"1_06_atom_urids_uris/","title":"06 - Atom, URIDs &amp; URIs","text":"<p>See video: https://youtu.be/EHpwO5yl66s</p> <p>Introduction into the data structures used in LV2: Atoms, URIDs and URIs.</p> <ul> <li>LV2_Atom: Data containers with information about type and size. LV2_Atoms may have a body to store data of different types (like int, float, double, string, ..., and even other atoms).</li> <li>Vectors are LV2_Atoms which contain an array of child data and information about the child type and the child size.</li> <li>Properties are \"named\" LV2_Atoms which contain a key URID and data (e.g., as LV2_Atoms again).</li> <li>Objects are LV2_Atoms which may take up multiple and/or different other property LV2_Atoms.</li> <li>Events are prefixed with a time stamp.</li> <li>And Sequences are LV2_atoms which can take up multiple events.</li> <li>URI: Unique identifier for each definition.</li> <li>URID: Serial number for an URI.</li> </ul>"},{"location":"1_07_simplest_midi_synth_1/","title":"07 - The Simplest MIDI Synth (Part 1)","text":"<p>See video: https://youtu.be/PuOeP-ln7UA</p> <p>Programming a simple MIDI sine synth LV2 plugin based on our myTestTone.</p> <p>Topics: * Implementation of the LV2 extensions:   * Atom   * Urid   * Midi * Understanding LV2 MIDI atoms * Programming a basic MIDI interpreter</p>"},{"location":"1_08_simplest_midi_synth_2/","title":"08 - The Simplest MIDI Synth (Part 2)","text":"<p>See video: https://youtu.be/-mnleLiofdI</p> <p>Programming a simple MIDI sine synth LV2 plugin based on our myTestTone.</p> <p>Topics: * MIDI data * Convert MIDI notes to audio frequency * ADSR envelope</p>"},{"location":"1_09_waveform_synth_cpp11/","title":"09 - Waveform Synth In C++ 11","text":"<p>See video: https://youtu.be/5zbQLFNZRoI</p> <p>Add a waveform selection feature (sine, triangle, square, saw, noise) to our synth. And this in modern C++. But first, we have to update our previously written code to C++11 too.</p> <p>Topics: * Enumerations in turtle using   * lv2:enumeration: https://lv2plug.in/ns/lv2core#enumeration   * lv2:integer: https://lv2plug.in/ns/lv2core#integer   * lv2:scalePoint: https://lv2plug.in/ns/lv2core#scalePoint * Exceptions   * The try catch block: https://en.cppreference.com/w/cpp/language/try_catch   * std::invalid_argument: https://en.cppreference.com/w/cpp/error/invalid_argument   * std::bad_alloc: https://en.cppreference.com/w/cpp/memory/new/bad_alloc * Streams   * std::cerr: https://en.cppreference.com/w/cpp/io/cerr * C++11 type casting   * static_cast: https://en.cppreference.com/w/cpp/language/static_cast   * reinterpret_cast: https://en.cppreference.com/w/cpp/language/reinterpret_cast * Standard template library containers   * std::array: https://en.cppreference.com/w/cpp/container/array * constexpr: https://en.cppreference.com/w/cpp/keyword/constexpr * Utilities   * std::pair: https://en.cppreference.com/w/cpp/utility/pair * Templates: https://en.cppreference.com/w/cpp/language/templates * Linear fader * Overloading * Waveform mathematics * Random generator: https://en.cppreference.com/w/cpp/numeric/random * Value distributions</p>"},{"location":"1_10_performance_polyphony/","title":"10 - Performance &amp; Polyphony","text":"<p>See video: https://youtu.be/uelx7poEMNY</p> <p>In the previous videos, we created a simple monosynth. This time, we will enable polyphony by the use of key containers. This video also shows the features and the limitations of the C++ standard template library (STL). And this video also shows different ways of increasing the plugin performance.</p> <p>Topics: * Header files * Polyphony using key as a std::array * Alternative STL containers   * std::vector   * std::map   * C++11 <code>for</code> loop   * Using interators   * Performance considerations   * Realtime compatibility * BUtility::BMap * Compiler flags (<code>-O3</code>, <code>-ffast-math</code>)</p>"},{"location":"1_11_programming_rt_audio/","title":"11 - Programming Realtime Audio","text":"<p>See video: https://youtu.be/h_UvVOu12aQ</p> <p>The basic concept of realtime audio we need for programming audio processing and sound generating plugins. Also showing the pitfalls for programming realtime audio plugins. Last video of the first tutorial block. Will be continued in 2022.</p> <p>Topics: * What is realtime? * Principle of audio signal routing * Realtime guarantee * Violating realtime * Not realtime-safe:   * User interactions   * Web access   * Other I/O   * Files, devices, pipes, sockets, system calls, ...   * Heap memory allocation and deallocation     * <code>malloc</code>, <code>calloc</code>, <code>free</code>, <code>new</code>, <code>delete</code>, ...     * C++ strings, streams, exceptions, STL containers (except <code>std::array</code>), ...   * Process / thread locks * LV2 realtime thread (<code>connect_port</code>, <code>run</code>) * Preview: LV2 worker extension</p>"},{"location":"2_00_announce/","title":"00 - Announce II","text":"<p>See video: https://youtu.be/7mCLDBBXajU</p> <p>Watch first the videos of Programming LV2 Plugins From Scratch I: https://www.youtube.com/watch?v=51eHCA4oCEI&amp;list=PLkuRaNsK2AJ0D8uhRIjftgmqVW0yvDfMx</p>"},{"location":"2_01_lv2_ui_intro/","title":"01 - Introduction Into LV2 UIs","text":"<p>See video: https://youtu.be/1HT2c5s82Ks</p> <p>There are different ways to create LV2 UIs. You can either use frameworks (to create a whole plugin including its UI) and designers or do it from scratch.</p> <p>Topics: * Frameworks:   * JUCE: https://juce.com   * DPF: https://github.com/DISTRHO/DPF * Designers:   * XUiDesigner: https://github.com/brummer10/XUiDesigner * Coding from the scratch:   * Interfaces to     * Mac     * Windows     * X11     * GTK     * Qt   * Resource: https://lv2plug.in/ns/extensions/ui</p>"},{"location":"2_02_simple_plugin_ui_gtk_1/","title":"02 - A Simple Plugin UI Using GTK (Part 1)","text":"<p>See video: https://youtu.be/hSnMVSIBfww</p> <p>Note: This video was made for teaching and demonstration of LV2UI. The use of GTK and Qt within plugins is not recommended.</p> <p>Create our first own graphical LV2 plugin user interface. First, we define our environment for programming LV2 UIs by: * add the UI metadata to the manifest (and a linked plugin turtle file) * create an UI binary file with   * a public C interface function for the LV2UI (export function)   * a static/private interface struct containing     * the UI URI     * function pointers to the four UI functions   * the four static/private UI functions     * instantiate     * cleanup     * port_event     * extension_data   * an UI class definition.</p> <p>This \"boilerplate\" can be used for all GTK3-based LV2 plugins. And with some minor adaptions for any LV2 plugin.</p> <p>GTK3: https://docs.gtk.org/gtk3/</p>"},{"location":"2_03_simple_plugin_ui_gtk_2/","title":"03 - A Simple Plugin UI Using GTK (Part 2)","text":"<p>See video: https://youtu.be/bVJ3WBRHAEg</p> <p>Note: This video was made for teaching and demonstration of LV2UI. The use of GTK and Qt within plugins is not recommended.</p> <p>Coding the GTK3 UI, main steps: * create a container (box) as a top level widget (in constructor) * create a vertical scale (slider) * add the slider to the box * set the slider value by values received from the plugin DSP (in portEvent) * define a callback function (valueChangedCallback) to handle changed slider values * link the callback function (in constructor) * send changed slider values to the plugin DSP (in valueChangedCallback)</p> <p>Build: * plugin DSP:</p> <pre><code>  gcc myAmp.c -fvisibility=hidden -fPIC -DPIC -shared -pthread -lm `pkg-config --cflags --libs lv2` -o myAmp.so\n</code></pre> <ul> <li>UI:</li> </ul> <pre><code>  g++ myAmp_GTK3.c -fvisibility=hidden -fPIC -DPIC -shared -pthread -lm `pkg-config --cflags --libs lv2 gtk+-3.0` -o myAmp_GTK3.so\n</code></pre> <ul> <li>Copy both .so files and the two .ttl files into a subfolder (e. g., myAmp_GTK3.lv2) of your lv2 directory.</li> </ul>"},{"location":"2_04_whats_so_bad_gtk/","title":"04 - What's Sooo Bad About GTK?","text":"<p>See video: https://www.youtube.com/watch?v=Mp58M9ZGeSs</p> <p>No, GTK is not bad! But the use within plugins is not recommended. And this is also true for other big GUI toolkits. Like Qt.</p> <p>Our GTK3-based Plugin UI doesn't work in Ardour. Why?</p> <p>On the other hand, if we make a GTK(2)-based version using <code>ui:GtkUI</code>, and compile it by:</p> <pre><code>g++ myAmp_GTK.c -fvisibility=hidden -fPIC -DPIC -shared -pthread -lm `pkg-config --cflags --libs lv2 gtk+-2.0` -o myAmp_GTK.so\n</code></pre> <p>Now it runs in Ardour. But it fails in jalv.gtk3. Why?</p> <p>Although LV2 contains specifications for GTK(2) and GTK3, * GTK3 plugin UIs don't work in GTK2 LV2 hosts (javl.gtk, Ardour) * GTK2 plugin UIs may fail in GTK3 LV2 hosts (jalv.gkt3, Zrythm) * any GTK-based plugins don't work in host which don't support GTK(2)/3 (Reaper).</p> <p>The reason: linking. There are two types of linking: * static linking (code included, at compile time) * dynamic linking (shared objects, at runtime)</p> <p>You can't dynamicly link to two different versions of the same library. And you don't have any control about the library loaded before.</p> <p>The solution: static linking (as much as possible). (Or provide UIs for all toolkits. But I wouldn't do all the work ;-)). But GTK, Qt and other big UI toolkits are made for dynamic linking. And they are full of compatibility breaks. Use UI toolkits which can be staticly linked, instead.</p> <p>Note: The linking process is shown in a much simplified way. There a more steps than shown in this video. Including relocation, symbol table, symbol resolution, ... . But this would be far beyond this tutorial series.</p> <p>And there are also different ways of loading plugins by the host.</p>"},{"location":"2_05_simple_plugin_ui_xputty_1/","title":"05 - Make A Simple Amp Plugin UI With XPutty","text":"<p>See video: https://youtu.be/no9pBAi-F1c</p> <p>We create an X11, Cairo-based graphical user interface with Xputty.</p> <p>Topics: * New requirements for X11:   * Declare as an X11 user interface: <code>ui:X11UI</code>   * Information about the host-provided parent window   * Interface for the to call the plugin UI event loops: idle interface     * <code>lv2:requiredFeature ui:idleInterface</code>     * <code>lv2:extensionData ui:idleInterface</code>   * Destructor to cleanup / deallocate plugin UI widgets * Construct the UI   * Init Xputty:<code>main_init ()</code>   * Create a top level widget: <code>create_window ()</code>   * Create a dial widget inside the top level widget: <code>add_knob ()</code>   * Link the dial to valueChangedCallback   * Add values and a value range: <code>set_adjustment ()</code>   * Visualize: <code>widget_show_all ()</code> * Set dial value via portEvent: <code>adj_set_value ()</code> * Get dial value in valueChangedCallback: <code>adj_get_value ()</code> * Idle interface   * Provide a static idle interface function   * Call <code>run_embedded ()</code>   * Link idle interface function in extension data</p>"},{"location":"2_06_simple_plugin_ui_xputty_2/","title":"06 - Make A Simple Amp Plugin UI With XPutty II","text":"<p>See video: https://youtu.be/lXYyu7Ta7C4</p> <p>We compile and optimize the Xputty-based plugin we made before.</p> <p>Compile: * Plugin DSP:</p> <pre><code>gcc myAmp.c -fvisibility=hidden -fPIC -DPIC -shared -pthread `pkg-config --cflags lv2` -Wl,-Bstatic -lm `pkg-config --libs --static lv2` -Wl,-Bdynamic -o myAmp.so\n</code></pre> <ul> <li>User interface:</li> </ul> <pre><code>g++ myAmp_Xputty.cpp -fvisibility=hidden -fPIC -DPIC -shared -pthread -Ilibxputty/libxputty/include `pkg-config --cflags lv2 cairo x11` -Llibxputty/libxputty -Wl,-Bstatic -lm `pkg-config --libs --static lv2` -Wl,-Bdynamic `pkg-config --libs cairo x11` -o myAmp_Xputty.so\n</code></pre> <ul> <li>Optimization:</li> <li>Load background image: <code>widget_get_png_from_file ()</code></li> <li>Visualize it in an expose event callback:<ul> <li><code>cairo_set_source_surface ()</code></li> <li><code>cairo_paint ()</code></li> </ul> </li> </ul>"},{"location":"build/","title":"Build the projects","text":""},{"location":"build/#xputty","title":"XPutty","text":"<p>XPutty is a small UI library useful to provide an UI to plugins on Linux.</p> <p>Currently we only provided a source package in AUR, the Archlinux User Repository, for convenience, so in order to build all plugins, included <code>myAmp_Xputty</code>, it is required to build it using <code>make</code>.</p> <p>The library can be built from a directory in this repository:</p> <pre><code>cd myAmp_Xputty/libxputty\nmake\ncd ../..\n</code></pre> <p>Now it's possible to build all projects at once in the next step.</p>"},{"location":"build/#cmake","title":"CMake","text":"<p>All projects can be built separately or at once with CMake. A <code>CMakeLists.txt</code> build configuration file is provided in the root directory.</p> <p>To build all projects with it:</p> <pre><code># - Configure a `Release` version of the project in a `build` directory by skipping\n#   developers' message warnings\n# - Build the project by showing compiler message options\n\ncmake -DCMAKE_BUILD_TYPE=Release -B build -Wno-dev\ncmake --build build --verbose\n</code></pre> <p>Getting a <code>Package 'xputty', required by 'virtual:world', not found</code> is normal if you don't have it installed in your system.</p>"}]}